"""
Facilities related to reading files and traversing directories.
"""

# This module is derived from pulling out the DirectoryTree, Directory,
# and related functionality from the tseqsrc module and making it reusable.

from abc import abstractmethod, ABC
import os
from pathlib import Path
import re
import sys
import traceback
from typing import Generator, Tuple, Any


# TextSource and BytesSource are not restricted to filesystems, of course,
# but we don't presently have a more general module to put them in.
class TextSource(ABC):

    @abstractmethod
    def texts(self) -> Generator[Tuple[Any, str], None, None]:
        pass


class BytesSource(ABC):

    @abstractmethod
    def bytes(self) -> Generator[Tuple[Any, bytes], None, None]:
        pass


# There's a bit of awkwardness regarding what is generated by texts() and
# bytes() to represent the file path associated with the file contents read.
#
# Above I use Any for full generality.
# In FileSystemSource I use Path because that seems appropriate.
# So calling code like the ConllU classes gets back paths.
#
# But for better compatibility with what tseqsrc did, I use the same
# source_files methods originally from tseqsrc and generate the paths
# from the strs that source_files generates.
#
# Then in the ConllU classes I convert the paths back to strings because
# the tseqsrc token_sequences method is defined to use strings.
# I'm not positive this is a 1-1 reversal of the original string to path
# conversion in all cases.
# (E.g., consider "~". And it might be better to have that expanded,
# though I haven't tested whether it would be.)
# I've done the same in the retrofitted tseqsrc.
#
# Perhaps I should forget about using Path and just use str,
# but I'm not quite ready to give up on Path.


# Could perhaps also define methods for opened filehandles for text and bytes?
class FileSystemSource(TextSource, BytesSource):

    def __init__(self, *, encoding="utf-8", **kwargs):
        self.encoding = encoding

    def texts(self) -> Generator[Tuple[Path, str], None, None]:
        """Generate paths and corresponding texts."""
        for path in self.paths():
            with open(path, "r", encoding=self.encoding) as fh:
                text = fh.read()
            yield path, text

    # Not tested yet.
    def bytes(self) -> Generator[Tuple[Path, bytes], None, None]:
        """Generate paths and corresponding texts."""
        for path in self.paths():
            with open(path, "rb") as fh:
                bytes_ = fh.read()
            yield path, bytes_

    @abstractmethod
    def paths(self) -> Generator[Path, None, None]:
        pass

    @abstractmethod
    def __len__(self) -> int:
        """Number of paths."""
        pass


class FileSource(FileSystemSource):
    """Handles a single text file specified by self.source_name."""

    def __init__(self, source_name, *, encoding="utf-8", **kwargs):
        super().__init__(encoding=encoding, **kwargs)
        self.source_name = source_name

    def paths(self):
        yield Path(self.source_name)

    def source_files(self) -> Generator[str, None, None]:
        yield self.source_name

    def __len__(self):
        return 1


class DirectorySource(FileSource):
    """Handles files in the self.source_name directory (omitting dotfiles)."""

    def __init__(self, source_name, *, encoding="utf-8", filter_regex=None, **kwargs):
        super().__init__(source_name, encoding=encoding, **kwargs)
        self.filter_regex = safe_compile_regex(filter_regex)

    def paths(self):
        for pathname in self.source_files():
            yield Path(pathname)

    # Note that currently the regex is applied to the filename, not the full path.
    def source_files(self) -> Generator[str, None, None]:
        """Generates file paths for files in the self.source_name directory
       ."""
        dirname = self.source_name
        files = sorted([f for f in os.listdir(dirname) if not f.startswith('.')])
        for f in files:
            if self.filter_regex is None or re.search(self.filter_regex, f):
                yield "%s/%s" % (dirname, f)

    def __len__(self):
        return len(list(self.source_files()))


# Compile so that if there is a problem with the regex, we know up front
# instead of getting an error on every filename we try to match.
def safe_compile_regex(pattern):
    """If pattern is None or there is an error compiling it, return None."""
    if pattern is None:
        return None
    try:
        return re.compile(pattern)
    except Exception as e:
        print("Could not compile regex: '%s'. A Python regex is expected, not a glob pattern." % pattern, file=sys.stderr)
        traceback.print_exc()
        return None


class DirectoryTreeSource(DirectorySource):
    """Like the parent class but also recurses into subdirectories."""

    def __init__(self, source_name, *, encoding="utf-8", filter_regex=None, **kwargs):
        super().__init__(source_name, encoding=encoding, filter_regex=filter_regex, **kwargs)

    # Note that currently the regex is applied to the full path, not the filename,
    # which is different from the parent class behavior.
    def source_files(self) -> Generator[str, None, None]:
        """Generates file paths for files in the self.source_name directory
        and its descendant directories (omitting dotfiles)."""

        def _recurse(dirname):
            files = sorted([f for f in os.listdir(dirname) if not f.startswith('.')])
            for f in files:
                path = "%s/%s" % (dirname, f)
                if os.path.isdir(path):
                    for f2 in _recurse(path):
                        yield f2
                elif os.path.isfile(path):
                    if self.filter_regex is None or re.search(self.filter_regex, path):
                        yield path

        return _recurse(self.source_name)
