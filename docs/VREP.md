# Valet Rules Enhancements

Valet Rules (VR) is proving to be a fairly useful library, but it's also
organically grown and is quite shaggy in places.  Some features are
well considered, whereas others feel like a pain.  This document
describes changes to VR, past and planned.

We'll call the version at the time of this writing (2019-11-20) VR 1.

## Versions

* [VR 1](ValetRules.md).  Note that VR1 has already drifted somewhat
  from the code documented behind that link, though not in ways that
  are not backwardly compatible.

## Planned changes 

* *Unit tests*. Introduces unit tests to the VR library.  This will be mainly
  about setting up the framework for such tests and implementing a few
  for the basic features.  As bugs are fixed or new features added,
  we'll make a point of including new tests to cover those changes.
* [*Range Operator*](#range-operators).  Will introduce a range
  operator to phrase expressions.  This is already implemented in a
  branch, so the work will be about reconciling the two branches.
* [*Simplified References*](#simplified-references). Normalizes how
  references are specified in expressions.  The syntax is getting a
  little perlish, and I'd like to think about how to manage some of
  the syntactic accretions.  This may entail some breaking changes to
  the syntax.
* [*Normalized Qualifiers*](#normalized-qualifiers). Normalizes how
  qualifiers are used on various statements and expressions.  This may
  entail some breaking changes to the syntax.
* [*Frame Statements*](#frame-statements). Stabilizes the syntax and
  behavior of the `frame` expression, which governs how matches are
  turned into composite extraction frames.
* [*Coordinator
  Normalization*](#coordinator-normalization). Coordinators have
  proliferated a little more than is healthy.  This will be an effort
  to determine the optimal set of operators, eliminating some of them,
  and simplifying the syntax with which they're specified.
* [*Non-greedy Kleene Operators*](#non-greedy-kleene-operators). We'll
  introduce non-greedy versions of `*` and `+` (i.e., `*?` and `+?`).

## Discussion of changes

### Range operators

This will add a numeric range operator to the regular expression
syntax used to define phrase extractors.  In addition to saying:

```
foo -> bar+
```

we'll be able to say:

```
foo -> bar{2,5}
```

to enforce a number of repetitions of `bar` ranging between 2 and 5.

### Simplified references

The `&` and `@` characters for signalling reference to a named
extractor seems like overkill.  Once possibility would be to get rid
of these characters altogether, and treat any token that could serve
as an extractor name as a potential reference, disambiguating based on
what has been defined so far.  But it probably makes most sense to
retain just `&` as a sigil indicating reference.  The policy will then
be to sweep through the set of possible extractors in some fixed order
to find the matcher.

We'll enhance the definition of `VRManager.parse_file()` to generate
warnings when a name is used more than once, so the programmer can
know that ambiguity of reference is possible.

One question is whether it should be allowed to make reference to
coordinators.  There's no reason why this shouldn't be possible in
principle, but it certainly would increase the odds of infinite loops
and other untoward effects.

### Normalized qualifiers

Currently, it's possible to attach lots of little characters in places
to effect interesting and useful variants in behavior.  For example:

```
vocab <- j{controlledVocab.json}is
```

says do a special kind of import, treating the indicated file as
source of a json structure that defines a number of lexical tests,
enforcing that they're case-insensitive, and stipulating that stemming
should be performed.

This task would be about deciding on the right syntax to support such
options and legislating a way to document those options.

### Frame statements

A frame statement is a kind of no-op coordinator that embeds
instructions for assembling an extraction frame from the match
generated by a coordinator.  For example:

```
msframe $ frame(measure_statement, measure=np adjnoun, value=number, unit=unit)
```

indicates how to generate an frame with three fields, `measure`,
`value`, and `unit` from a match returned by the `measure_statement`
coordinator. 

Its current syntax and behavior is a little half-baked.  This task
would complete this initial implementation and document the new
facility.

### Coordinator normalization

Coordinators are quite useful in certain circumstances, but perhaps a
little too verbose, and there are two many of them.  This task would:

1. Refactor and reduce the set of available coordinators.
2. Simplify their syntax by adding support for optional arguments,
   probably in a way that mimics python named arguments.
3. Make backend changes to ensure that the surviving coordinators are
   first-class citizens.

There may be uses of coordinators that we haven't considered but could
pursue, as well.  For example, sometimes it's desirable to apply
phrase extractors in a case-insensitive fashion.  If we can figure out
how to implement this, it could be controlled a variant of the `match`
coordinator. 

### Non-greedy Kleene operators

The expression:

```
parenthetical -> &lparen &any_token* &rparen
```

might yield unintended results when applied to a token sequence with
multiple parenthetical expressions.  The notional `any_token` test
consumes parentheses along with all other types of tokens.  In this
task, we're contemplating something like:

```
parenthetical -> &lparen &any_token*? &rparen
```

which would force the `any_token` to consume as few intervening tokens
as possible.

